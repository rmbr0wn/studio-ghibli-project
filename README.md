# Studio Ghibli Project

> A React + GraphQL application showcasing Studio Ghibli films. This monorepo contains both frontend and backend packages managed through [lerna](https://github.com/lerna/lerna).

## Getting Started

### Prerequisites

Ensure you have Node.js version 20.11 installed:

```bash
nvm install 20.11
nvm use
```

The `.nvmrc` file in the root of this project will default to node 20.11 if you run `nvm use`.
Confirm your Node.js version by running `node --version`.

### Install pnpm

This project uses pnpm for package management. Install it by following the [pnpm installation instructions](https://pnpm.io/installation).

### Setup Instructions

1. **Clone the repository**:

   ```bash
   git clone <your-fork-url>
   cd studio-ghibli-project
   ```

2. **Install dependencies**:

   ```bash
   pnpm install
   ```

   We use [pnpm workspaces](https://pnpm.io/workspaces) for dependency sharing between packages.

3. **Copy .env.example values into .env file**:

   ```bash
   cp ./packages/backend/.env.example ./packages/backend/.env
   cp ./packages/frontend/.env.example ./packages/frontend/.env
   ```

4. **Start the development servers**:

- **Backend (GraphQL Server)**:

  ```bash
  cd packages/backend
  pnpm dev
  ```

  The GraphQL server will start on `http://localhost:8080`

- **Frontend (React App)**:

  ```bash
  cd packages/frontend
  pnpm dev
  ```

  The React app will start on `http://localhost:3000`

## Project Structure

- `packages/backend/` - GraphQL server with Apollo Server
- `packages/frontend/` - React application with Apollo Client

## Available Scripts

### Backend

- `pnpm dev` - Start development server with hot reload
- `pnpm build` - Build for production
- `pnpm test` - Run tests

### Frontend

- `pnpm dev` - Start development server
- `pnpm build` - Build for production
- `pnpm test` - Run tests

## Documentation Deliverables

### Setup Instructions

- See above â€“ I didn't modify the setup at all.

### Project Overview

- The entirety of the frontend code is written inside `/packages/frontend/src/modules/home/Home.tsx`, with the test file `Home.test.tsx` located in the same folder.

- The GraphQL backend files changed are listed in the `/tasks/tasks-prd-studio-ghibli.md` file.

- I used Tailwind for custom styling to try and align it closely with the design mockups given in Zeplin.

### Dev-Tasks Process

I followed the steps given in the "Development Process (Required)" section of the Notion document, but I will explain in more detail what I did:

1. I provided the necessary files as context for creating the PRD (`.cursor/.rules/create-prd`, `cursorules`).
2. I copied and pasted the task overview, frontend features and backend features from the Notion document, and asked the agent to proceed with creating the PRD according to those requirements.
3. After reading through the PRD and feeling satisfied with the results, I attached similar files as per step #1 (alongside `generate-tasks.mdc`), and asked the agent to generate the task list.
4. I reviewed the task list generated, and then asked the agent to process the task list one sub-task at a time (while passing in the `process-task-list.mdc` as context).
5. At the end of each parent task I asked the agent to create tests, run those tests, and then commit (as per the requirements).

- **Note:** Please see `/tasks/prd-studio-ghibli.md` and `tasks-prd-studio-ghibli.md` for the relevant agent generated files.

### Time Spent

- **~7.5 hours overall**
- **~3.5 - 4 hours** working with the agent to complete tasks, modify generated code, fine-tune requirements, and style the JSX.
- The remaining time was spent working through somewhat unrelated issues (see "Challenges" below for more info).

### Rationale (Technology/Architecture)

I didn't modify the existing architecture/technology much. The main technology decision I did make was to use TailwindCSS for styling, and I chose Tailwind for 2 reasons:

1. I thought it would be quick for one-off designs like this.
2. It is the CSS framework I'm most familiar with, which again I thought would allow me to work more quickly.

However, for a larger project where reusable/modular components with a cohesive style are desired/necessary, I would likely look at something like MaterialUI or a similar component library in place of Tailwind (or perhaps in addition to Tailwind).

### Challenges

- I was using a Virtual Machine running Linux with VSCode, and when using the agent mode my VSCode repeatedly froze and crashed.
  - This alone consumed at least 2-3 hours of my time since I had to repeatedly close the editor, restart it, and re-run any prior prompts (assuming the agent didn't finish its work in time).
- I had issues running the initial code generated by the agent due to the agent's code relying on missing GraphQL queries, which repeatedly threw errors. This probably consumed ~1-1.5 hours of my time.
  - In hindsight, what I should have done from the beginning was simply continue with the agent code generation and have it fix the errors once it got to them. This is what I eventually ended up doing, but I wasted some time trying to manually fix things myself (and I don't have any prior GraphQL experience which made it even more challenging).

### Limitations

- Beyond using responsive design mode in the browser, I didn't verify mobile functionality (e.g. tapping to flip cards), so I don't know how the site will perform on actual mobile devices.

### Future Improvements

- **Error handling**: This didn't seem necessary for the project, but I would definitely add error handling for the GraphQL queries so that errors don't crash the frontend application.
- **Better modular design**: Instead of everything in the `Home.tsx` file, I would likely create components like `GhibliCard.tsx` (or similar) to have proper separation of concerns, better modularity, and less of a wall of JSX.
- **A better way of viewing the full movie descriptions**: Currently it overflows to an ellipsis, which is probably fine for the scope of the project, but it would be ideal for the user to be able to read it.
  - This could likely be done via dynamically resizing cards (instead of fixed size), or perhaps taking another more thoughtful approach to card information organization.

### Final Comments

- I wanted to say that I appreciate the detailed and well-formatted instructions for this assignment! There was no real ambiguity with any of the steps, and it was easy to follow along and refer to.

- I also wanted to say thank you for introducing me to this structured agentic workflow. I've been using LLMs for years to help write code, but I have never seen an approach like this! It works wonders, and I will definitely be stealing it for the future.
